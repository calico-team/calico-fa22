"""
Test case generator utility functions custom-built from scratch by Jeffrey Tong
(jewato100022) for CALICO.

Last updated 2023-01-31
"""
import random, pathlib as pl, shutil

class InputFile:
	"""Stores the data for an arbitrarily input file, equipped with a default
	`__str__` bound method for use in `SetGen.write_file`
	"""

	def __init__ (self, data):
		"""By default, assume `self.data` is a list of T tests, each represented
		as iterables (in particular, strings, lists, and ranges work well) of
		possibly varying lengths. `random` will be seeded with the seed of
		`self.set_gen`, if it exists.

		data -- the data for the input file in any format, by convention
		usually a list of T tests, each of which are iterables (in particular,
		lists or strings) of possibly varying lengths
		"""
		self.data = data
		random.seed(SetGen.seed)
	
	def __str__ (self) -> str:
		"""By default, assume the first line of the text representation should
		be T. Then for each test, the first line is the number N of data values.
		The second line for each test is either a spaced list of the test's
		entries [l_1] [l_2] ... [l_N] (for lists) or [s_1][s_2]...[s_N] (for
		strings).
		"""
		txt = str(len(self.data))
		for test in self.data:
			txt += f'\n{len(test)}\n'
			if type(test) is not str:
				test = ' '.join([str(a_i) for a_i in test])
			txt += test
		return txt

# File paths longer than this many characters will be clipped in the table
MAX_PATH_LENGTH = 30

class SetGen:
	"""Set generator for handling output, file counting, and disk I/O for a
	single set of test files under the same constraints
	"""
	seed = 0 # Global seed for all future input files

	def __init__ (
		self,
		target: str,
		seed: int | str = None,
		clear: bool = False,
		prefix: str = '',
		num_digits: int = 1
	):
		"""Configures the generator to write files for a test set at the same
		directory. If the directory at `target` does not exist, a new one will
		be created with applicable parents. If `clear` is true, an empty
		directory will be created at `target`, overwriting the existing one.
		
		target -- the directory to write files to for this set
		seed -- seed used for seeding `random` in future instances of
		`InputFile`
		clear -- whether to clear any existing directory at `target`
		prefix -- an optional string to add to the beginning of test file base
		names to distinguish multiple test sets for the same problem
		num_digits -- all file names will use at least this many digits to
		represent test case numbers, padding with zeroes as necessary.
		"""
		if seed != None:
			assert type(seed) in (int, str), 'seed type must be int or str'
			SetGen.seed = seed
			print(f'Set global seed to {seed}')
		self.target, self.prefix, self.num_digits = target, prefix, num_digits
		self.file_cnt = 0 # Count of files generated by this `SetGen` so far
		path = pl.Path(target)
		if path.exists() and clear:
			shutil.rmtree(path)
			print(f'- {path}')
		if not path.exists():
			path.mkdir(parents = True)
			print(f'+ {path}')
	
	def write_file (self, source: str | InputFile, comment: str = ''):
		"""Increments the case counter of this `SetGen`, then writes a test case
		to a file inside the `path`, appending the current file index and ".in"
		to the file name. Thus, the file names will be 1.in, 2.in, etc. A table
		row entry will be printed. Lastly, it returns itself, enabling chaining
		of `write_file` calls.

		source -- the plain text or an `InputFile` instance describing the case
		comment -- short description that helps identify the file in logs
		"""
		assert type(source) is str or isinstance(source, InputFile)
		self.file_cnt += 1
		padded_cnt = str(self.file_cnt).zfill(self.num_digits)
		output_path = pl.Path(self.target) / f'{self.prefix}{padded_cnt}.in'
		plain_text = str(source) + '\n'
		with open(output_path, 'w', newline = '\n') as f:
			f.write(plain_text)
		
		output_path = str(output_path)
		if len(output_path) > MAX_PATH_LENGTH:
			output_path = output_path[:MAX_PATH_LENGTH - 3] + '...'
		line_cnt, char_cnt = len(plain_text.splitlines()), len(plain_text)
		print(
			# Works best with line_cnt < 10^7 and char_cnt < 10^8
			f'+ {output_path:{MAX_PATH_LENGTH}} <- {line_cnt:7} ln  '
			f'{char_cnt:8} ch' + ('  ' + comment if comment else '')
		)
		return self

def r (x: int) -> range:
	"""Returns a range containing only one value.

	x -- the value to contain
	"""
	return range(x, x + 1)

def r2 (n: int) -> range:
	"""Returns `range(1, n + 1)` (a range shifted upwards by 1). Useful for
	inputs constrained to positive values.

	n -- the greatest value in the range.
	"""
	return range(1, n + 1)

def make_partition (n: int, k: int) -> list[int]:
	"""Creates an integer partition of n into k positive summands
	a_1 + ... + a_k = n uniformly at random, returning a list of length k.

	n -- a positive integer to partition
	k -- the number of parts
	"""
	assert n >= k, "more summands than the sum"
	# By stars and bars, this is equivalent to choosing k - 1 of n - 1 slots
	# to place a bar in.
	splits = [0] + sorted(random.sample(range(1, n), k - 1)) + [n]
	return [splits[i + 1] - splits[i] for i in range(k)]

class MultiTestFile (InputFile):
	"""Subclass of `InputFile` enforcing the convention of adding multiple
	independent tests per test file, subject to the constraint that the sums of
	the tests' magnitudes is limited
	"""

	def __init__ (
		self,
		data,
		t_range: range = range(1, 101),
		sum_range: range = range(1, 10 ** 5 + 1)
	):
		"""Randomly selects `self.t`, `self.sum_n`, and `self.partition` as
		specified. Checks for `t_range` and `sum_range` constraints must be
		performed separately.

		data -- passed to `InputFile`
		t_range -- T (number of tests in the file) is randomly selected from
		`t_range`
		sum_range -- `sum_n`, the sum of N (number of data values) over all
		individual tests, is randomly selected from the interval
		[max(`sum_range.start`, T), `sum_range.stop`). Each N is then selected
		randomly from all the integer partitions of `sum_n` into T summands.
		"""
		assert t_range.start >= 0
		assert sum_range.stop >= t_range.stop, 'cannot guarantee all N > 0'
		super().__init__(data)
		self.t = random.choice(t_range)
		self.sum_n = random.choice(
			range(max(sum_range.start, self.t), sum_range.stop)
		)
		self.partition = make_partition(self.sum_n, self.t)